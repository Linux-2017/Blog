{"title":"IO模型","slug":"io模型","date":"2017-04-02T04:00:09.000Z","updated":"2017-12-09T13:57:46.000Z","comments":true,"excerpt":"","content":"<h1 id=\"i-o模型\"><a href=\"#i-o模型\" class=\"headerlink\" title=\"i/o模型\"></a><strong>i/o模型</strong></h1><h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><p>关注的是消息通知机制</p>\n<p>同步:调用发出之后不会立即返回，但一旦返回，即是最终结果</p>\n<p>异步:调用发出之后立即返回消息，但返回的并非最终结果;被调用者通过状态、通知机制等来通知调用者，或通过回调函数来处理</p>\n<h3 id=\"阻塞和非阻塞\"><a href=\"#阻塞和非阻塞\" class=\"headerlink\" title=\"阻塞和非阻塞\"></a>阻塞和非阻塞</h3><p>关注的是调用者等待被调用者返回结果时的状态</p>\n<p>阻塞:调用结果返回之前，调用者会被挂起，调用者只有在得到返回结果之后才能继续;</p>\n<p>非阻塞:调用者在返回结果之前，不会被挂起，即调用不会阻塞调用者;</p>\n<h3 id=\"i-o复用模型\"><a href=\"#i-o复用模型\" class=\"headerlink\" title=\"i/o复用模型\"></a>i/o复用模型</h3><p>I/O复用模型会用到select或者poll函数，这两个函数会使进程阻塞，但是和阻塞不同的是，这个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个i/o函数进行检测，直到有数据可读或可写时，才真正调用i/o操作函数。</p>\n<h3 id=\"信号驱动I-O模型\"><a href=\"#信号驱动I-O模型\" class=\"headerlink\" title=\"信号驱动I/O模型\"></a>信号驱动I/O模型</h3><p>该模型也叫做事件驱动的I/O模型，这个模型首先允许套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行时并不阻塞。当数据准备好时，进程会受到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>\n<h3 id=\"异步I-O模型\"><a href=\"#异步I-O模型\" class=\"headerlink\" title=\"异步I/O模型\"></a>异步I/O模型</h3><p>调用aio_read函数，告诉内核描述子，缓冲区指针，缓存区大小，文件偏移以及通知的方式，然后立刻返回。当内核数据拷贝到缓冲区后，在通知应用程序。</p>\n<p>### </p>\n","categories":[{"name":"Linux","path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","path":"api/tags/Linux.json"},{"name":"Notes","path":"api/tags/Notes.json"}]}